2025-08-20T08:05:03.687720Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=643.936µs elapsed_secs=0.000643936
2025-08-20T08:05:03.688465Z DEBUG sqlx::query: summary="SELECT pg_advisory_lock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=665.542µs elapsed_secs=0.000665542
2025-08-20T08:05:03.688862Z  INFO sqlx::postgres::notice: relation "_sqlx_migrations" already exists, skipping
2025-08-20T08:05:03.688900Z DEBUG sqlx::query: summary="CREATE TABLE IF NOT …" db.statement="\n\n\nCREATE TABLE IF NOT EXISTS _sqlx_migrations (\n    version BIGINT PRIMARY KEY,\n    description TEXT NOT NULL,\n    installed_on TIMESTAMPTZ NOT NULL DEFAULT now(),\n    success BOOLEAN NOT NULL,\n    checksum BYTEA NOT NULL,\n    execution_time BIGINT NOT NULL\n);\n                \n" rows_affected=0 rows_returned=0 elapsed=386.034µs elapsed_secs=0.000386034
2025-08-20T08:05:03.690424Z DEBUG sqlx::query: summary="SELECT version FROM _sqlx_migrations …" db.statement="\n\nSELECT version FROM _sqlx_migrations WHERE success = false ORDER BY version LIMIT 1\n" rows_affected=0 rows_returned=0 elapsed=1.456045ms elapsed_secs=0.001456045
2025-08-20T08:05:03.690851Z DEBUG sqlx::query: summary="SELECT version, checksum FROM …" db.statement="\n\nSELECT version, checksum FROM _sqlx_migrations ORDER BY version\n" rows_affected=1 rows_returned=1 elapsed=380.266µs elapsed_secs=0.000380266
2025-08-20T08:05:03.691180Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=261.96µs elapsed_secs=0.00026196
2025-08-20T08:05:03.691465Z DEBUG sqlx::query: summary="SELECT pg_advisory_unlock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=243.256µs elapsed_secs=0.000243256
2025-08-20T08:05:03.691536Z  INFO backend: Database connection established.
2025-08-20T08:05:03.692369Z  INFO backend: Server listening on 0.0.0.0:8085
2025-08-20T08:05:16.765593Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=622.644µs elapsed_secs=0.000622644
2025-08-20T08:05:16.766207Z DEBUG sqlx::query: summary="SELECT pg_advisory_lock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=522.994µs elapsed_secs=0.000522994
2025-08-20T08:05:16.766575Z  INFO sqlx::postgres::notice: relation "_sqlx_migrations" already exists, skipping
2025-08-20T08:05:16.766636Z DEBUG sqlx::query: summary="CREATE TABLE IF NOT …" db.statement="\n\n\nCREATE TABLE IF NOT EXISTS _sqlx_migrations (\n    version BIGINT PRIMARY KEY,\n    description TEXT NOT NULL,\n    installed_on TIMESTAMPTZ NOT NULL DEFAULT now(),\n    success BOOLEAN NOT NULL,\n    checksum BYTEA NOT NULL,\n    execution_time BIGINT NOT NULL\n);\n                \n" rows_affected=0 rows_returned=0 elapsed=381.644µs elapsed_secs=0.000381644
2025-08-20T08:05:16.768010Z DEBUG sqlx::query: summary="SELECT version FROM _sqlx_migrations …" db.statement="\n\nSELECT version FROM _sqlx_migrations WHERE success = false ORDER BY version LIMIT 1\n" rows_affected=0 rows_returned=0 elapsed=1.337817ms elapsed_secs=0.001337817
2025-08-20T08:05:16.768537Z DEBUG sqlx::query: summary="SELECT version, checksum FROM …" db.statement="\n\nSELECT version, checksum FROM _sqlx_migrations ORDER BY version\n" rows_affected=1 rows_returned=1 elapsed=479.753µs elapsed_secs=0.000479753
2025-08-20T08:05:16.768850Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=221.617µs elapsed_secs=0.000221617
2025-08-20T08:05:16.769157Z DEBUG sqlx::query: summary="SELECT pg_advisory_unlock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=258.283µs elapsed_secs=0.000258283
2025-08-20T08:05:16.769228Z  INFO backend: Database connection established.
2025-08-20T08:05:16.770099Z  INFO backend: Server listening on 0.0.0.0:8085
2025-08-20T12:48:35.862397Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=634.158µs elapsed_secs=0.000634158
2025-08-20T12:48:35.862910Z DEBUG sqlx::query: summary="SELECT pg_advisory_lock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=413.01µs elapsed_secs=0.00041301
2025-08-20T12:48:35.863233Z  INFO sqlx::postgres::notice: relation "_sqlx_migrations" already exists, skipping
2025-08-20T12:48:35.863269Z DEBUG sqlx::query: summary="CREATE TABLE IF NOT …" db.statement="\n\n\nCREATE TABLE IF NOT EXISTS _sqlx_migrations (\n    version BIGINT PRIMARY KEY,\n    description TEXT NOT NULL,\n    installed_on TIMESTAMPTZ NOT NULL DEFAULT now(),\n    success BOOLEAN NOT NULL,\n    checksum BYTEA NOT NULL,\n    execution_time BIGINT NOT NULL\n);\n                \n" rows_affected=0 rows_returned=0 elapsed=310.104µs elapsed_secs=0.000310104
2025-08-20T12:48:35.864755Z DEBUG sqlx::query: summary="SELECT version FROM _sqlx_migrations …" db.statement="\n\nSELECT version FROM _sqlx_migrations WHERE success = false ORDER BY version LIMIT 1\n" rows_affected=0 rows_returned=0 elapsed=1.448397ms elapsed_secs=0.001448397
2025-08-20T12:48:35.865194Z DEBUG sqlx::query: summary="SELECT version, checksum FROM …" db.statement="\n\nSELECT version, checksum FROM _sqlx_migrations ORDER BY version\n" rows_affected=1 rows_returned=1 elapsed=392.2µs elapsed_secs=0.0003922
2025-08-20T12:48:35.865398Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=130.23µs elapsed_secs=0.00013023
2025-08-20T12:48:35.865690Z DEBUG sqlx::query: summary="SELECT pg_advisory_unlock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=243.243µs elapsed_secs=0.000243243
2025-08-20T12:48:35.865747Z  INFO backend: Database connection established.
2025-08-20T12:48:35.866683Z  INFO backend: Server listening on 0.0.0.0:8085
2025-08-20T12:53:30.709936Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=508.241µs elapsed_secs=0.000508241
2025-08-20T12:53:30.710465Z DEBUG sqlx::query: summary="SELECT pg_advisory_lock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=441.242µs elapsed_secs=0.000441242
2025-08-20T12:53:30.710814Z  INFO sqlx::postgres::notice: relation "_sqlx_migrations" already exists, skipping
2025-08-20T12:53:30.710843Z DEBUG sqlx::query: summary="CREATE TABLE IF NOT …" db.statement="\n\n\nCREATE TABLE IF NOT EXISTS _sqlx_migrations (\n    version BIGINT PRIMARY KEY,\n    description TEXT NOT NULL,\n    installed_on TIMESTAMPTZ NOT NULL DEFAULT now(),\n    success BOOLEAN NOT NULL,\n    checksum BYTEA NOT NULL,\n    execution_time BIGINT NOT NULL\n);\n                \n" rows_affected=0 rows_returned=0 elapsed=335.034µs elapsed_secs=0.000335034
2025-08-20T12:53:30.712164Z DEBUG sqlx::query: summary="SELECT version FROM _sqlx_migrations …" db.statement="\n\nSELECT version FROM _sqlx_migrations WHERE success = false ORDER BY version LIMIT 1\n" rows_affected=0 rows_returned=0 elapsed=1.288161ms elapsed_secs=0.001288161
2025-08-20T12:53:30.712513Z DEBUG sqlx::query: summary="SELECT version, checksum FROM …" db.statement="\n\nSELECT version, checksum FROM _sqlx_migrations ORDER BY version\n" rows_affected=1 rows_returned=1 elapsed=310.161µs elapsed_secs=0.000310161
2025-08-20T12:53:30.712795Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=215.327µs elapsed_secs=0.000215327
2025-08-20T12:53:30.713079Z DEBUG sqlx::query: summary="SELECT pg_advisory_unlock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=241.163µs elapsed_secs=0.000241163
2025-08-20T12:53:30.713135Z  INFO backend: Database connection established.
2025-08-20T12:53:30.713965Z  INFO backend: Server listening on 0.0.0.0:8085
2025-08-20T17:17:50.878825Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=623.351µs elapsed_secs=0.000623351
2025-08-20T17:17:50.879427Z DEBUG sqlx::query: summary="SELECT pg_advisory_lock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=525.383µs elapsed_secs=0.000525383
2025-08-20T17:17:50.879693Z  INFO sqlx::postgres::notice: relation "_sqlx_migrations" already exists, skipping
2025-08-20T17:17:50.879720Z DEBUG sqlx::query: summary="CREATE TABLE IF NOT …" db.statement="\n\n\nCREATE TABLE IF NOT EXISTS _sqlx_migrations (\n    version BIGINT PRIMARY KEY,\n    description TEXT NOT NULL,\n    installed_on TIMESTAMPTZ NOT NULL DEFAULT now(),\n    success BOOLEAN NOT NULL,\n    checksum BYTEA NOT NULL,\n    execution_time BIGINT NOT NULL\n);\n                \n" rows_affected=0 rows_returned=0 elapsed=248.656µs elapsed_secs=0.000248656
2025-08-20T17:17:50.880961Z DEBUG sqlx::query: summary="SELECT version FROM _sqlx_migrations …" db.statement="\n\nSELECT version FROM _sqlx_migrations WHERE success = false ORDER BY version LIMIT 1\n" rows_affected=0 rows_returned=0 elapsed=1.205978ms elapsed_secs=0.001205978
2025-08-20T17:17:50.881393Z DEBUG sqlx::query: summary="SELECT version, checksum FROM …" db.statement="\n\nSELECT version, checksum FROM _sqlx_migrations ORDER BY version\n" rows_affected=1 rows_returned=1 elapsed=386.283µs elapsed_secs=0.000386283
2025-08-20T17:17:50.881610Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=132.33µs elapsed_secs=0.00013233
2025-08-20T17:17:50.881979Z DEBUG sqlx::query: summary="SELECT pg_advisory_unlock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=325.876µs elapsed_secs=0.000325876
2025-08-20T17:17:50.882040Z  INFO backend: Database connection established.
2025-08-20T17:17:50.882881Z  INFO backend: Server listening on 0.0.0.0:8085
2025-08-20T17:17:56.395813Z TRACE axum::serve: connection 127.0.0.1:55630 accepted
2025-08-20T17:17:56.407065Z DEBUG backend::api::middleware: No Authorization header found in optional middleware
2025-08-20T17:17:56.412141Z TRACE axum::serve: connection 127.0.0.1:55642 accepted
2025-08-20T17:17:56.412243Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=0 rows_returned=0 elapsed=4.724589ms elapsed_secs=0.004724589
2025-08-20T17:17:56.413700Z DEBUG backend::api::middleware: No Authorization header found in optional middleware
2025-08-20T17:17:56.414679Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=0 rows_returned=0 elapsed=729.34µs elapsed_secs=0.00072934
2025-08-20T17:18:22.689990Z TRACE hyper_util::client::legacy::pool: checkout waiting for idle connection: ("https", www.googleapis.com)
2025-08-20T17:18:22.690097Z TRACE hyper_util::client::legacy::connect::http: Http::connect; scheme=Some("https"), host=Some("www.googleapis.com"), port=None
2025-08-20T17:18:22.723826Z DEBUG hyper_util::client::legacy::connect::http: connecting to [2404:6800:4002:811::200a]:443
2025-08-20T17:18:22.826109Z DEBUG hyper_util::client::legacy::connect::http: connected to [2404:6800:4002:811::200a]:443
2025-08-20T17:18:22.930802Z TRACE hyper_util::client::legacy::client: http1 handshake complete, spawning background dispatcher task
2025-08-20T17:18:22.930865Z TRACE hyper_util::client::legacy::client: waiting for connection to be ready
2025-08-20T17:18:22.930966Z TRACE hyper_util::client::legacy::client: connection is ready
2025-08-20T17:18:22.931011Z TRACE hyper_util::client::legacy::pool: checkout dropped for ("https", www.googleapis.com)
2025-08-20T17:18:23.109866Z TRACE hyper_util::client::legacy::pool: pool dropped, dropping pooled (("https", www.googleapis.com))
2025-08-20T17:18:23.116800Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=0 rows_returned=0 elapsed=6.333831ms elapsed_secs=0.006333831
2025-08-20T17:18:23.143928Z DEBUG sqlx::query: summary="INSERT INTO users (google_id, …" db.statement="\n\nINSERT INTO users (google_id, email, full_name, picture) VALUES ($1, $2, $3, $4) RETURNING *\n" rows_affected=1 rows_returned=1 elapsed=3.299964ms elapsed_secs=0.003299964
2025-08-20T17:18:23.150304Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=327.677µs elapsed_secs=0.000327677
2025-08-20T17:18:23.150422Z DEBUG backend::api::middleware: Valid token found for user in optional middleware
2025-08-20T17:18:23.153770Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=0 rows_returned=0 elapsed=3.116744ms elapsed_secs=0.003116744
2025-08-20T17:18:26.097826Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=252.693µs elapsed_secs=0.000252693
2025-08-20T17:18:26.097944Z DEBUG backend::api::middleware: Valid token found for user
2025-08-20T17:18:26.110829Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=1.152704ms elapsed_secs=0.001152704
2025-08-20T17:18:26.110921Z DEBUG backend::api::middleware: Valid token found for user in optional middleware
2025-08-20T17:18:26.112120Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=0 rows_returned=0 elapsed=1.019509ms elapsed_secs=0.001019509
2025-08-20T17:18:26.121979Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=227.474µs elapsed_secs=0.000227474
2025-08-20T17:18:26.122059Z DEBUG backend::api::middleware: Valid token found for user
2025-08-20T17:18:26.135228Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=231.22µs elapsed_secs=0.00023122
2025-08-20T17:18:26.135316Z DEBUG backend::api::middleware: Valid token found for user in optional middleware
2025-08-20T17:18:26.136433Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=0 rows_returned=0 elapsed=935.771µs elapsed_secs=0.000935771
2025-08-20T17:18:27.989471Z DEBUG backend::api::middleware: No Authorization header found in optional middleware
2025-08-20T17:18:27.990604Z DEBUG backend::api::middleware: No Authorization header found in optional middleware
2025-08-20T17:18:27.990780Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=0 rows_returned=0 elapsed=950.111µs elapsed_secs=0.000950111
2025-08-20T17:18:27.991649Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=0 rows_returned=0 elapsed=663.465µs elapsed_secs=0.000663465
2025-08-20T17:18:51.799286Z DEBUG backend::api::middleware: No Authorization header found in optional middleware
2025-08-20T17:18:51.800512Z DEBUG backend::api::middleware: No Authorization header found in optional middleware
2025-08-20T17:18:51.800784Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=0 rows_returned=0 elapsed=904.406µs elapsed_secs=0.000904406
2025-08-20T17:18:51.801584Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=0 rows_returned=0 elapsed=780.836µs elapsed_secs=0.000780836
2025-08-20T17:19:33.979147Z TRACE axum::serve: connection 127.0.0.1:57892 accepted
2025-08-20T17:19:33.983196Z DEBUG backend::api::middleware: No Authorization header found in optional middleware
2025-08-20T17:19:33.983498Z TRACE axum::serve: connection 127.0.0.1:57908 accepted
2025-08-20T17:19:33.984610Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=0 rows_returned=0 elapsed=1.056724ms elapsed_secs=0.001056724
2025-08-20T17:19:33.988224Z DEBUG backend::api::middleware: No Authorization header found in optional middleware
2025-08-20T17:19:33.989316Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=0 rows_returned=0 elapsed=740.768µs elapsed_secs=0.000740768
2025-08-20T17:27:34.697275Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=731.376µs elapsed_secs=0.000731376
2025-08-20T17:27:34.697852Z DEBUG sqlx::query: summary="SELECT pg_advisory_lock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=495.324µs elapsed_secs=0.000495324
2025-08-20T17:27:34.698142Z  INFO sqlx::postgres::notice: relation "_sqlx_migrations" already exists, skipping
2025-08-20T17:27:34.698181Z DEBUG sqlx::query: summary="CREATE TABLE IF NOT …" db.statement="\n\n\nCREATE TABLE IF NOT EXISTS _sqlx_migrations (\n    version BIGINT PRIMARY KEY,\n    description TEXT NOT NULL,\n    installed_on TIMESTAMPTZ NOT NULL DEFAULT now(),\n    success BOOLEAN NOT NULL,\n    checksum BYTEA NOT NULL,\n    execution_time BIGINT NOT NULL\n);\n                \n" rows_affected=0 rows_returned=0 elapsed=282.53µs elapsed_secs=0.00028253
2025-08-20T17:27:34.699325Z DEBUG sqlx::query: summary="SELECT version FROM _sqlx_migrations …" db.statement="\n\nSELECT version FROM _sqlx_migrations WHERE success = false ORDER BY version LIMIT 1\n" rows_affected=0 rows_returned=0 elapsed=1.107391ms elapsed_secs=0.001107391
2025-08-20T17:27:34.699781Z DEBUG sqlx::query: summary="SELECT version, checksum FROM …" db.statement="\n\nSELECT version, checksum FROM _sqlx_migrations ORDER BY version\n" rows_affected=1 rows_returned=1 elapsed=409.716µs elapsed_secs=0.000409716
2025-08-20T17:27:34.700018Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=169.367µs elapsed_secs=0.000169367
2025-08-20T17:27:34.700463Z DEBUG sqlx::query: summary="SELECT pg_advisory_unlock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=396.176µs elapsed_secs=0.000396176
2025-08-20T17:27:34.700521Z  INFO backend: Database connection established.
2025-08-20T17:27:34.701356Z  INFO backend: Server listening on 0.0.0.0:8085
2025-08-20T17:27:42.413893Z TRACE axum::serve: connection 127.0.0.1:32864 accepted
2025-08-20T17:27:42.424548Z TRACE hyper_util::client::legacy::pool: checkout waiting for idle connection: ("https", www.googleapis.com)
2025-08-20T17:27:42.424681Z TRACE hyper_util::client::legacy::connect::http: Http::connect; scheme=Some("https"), host=Some("www.googleapis.com"), port=None
2025-08-20T17:27:42.457020Z DEBUG hyper_util::client::legacy::connect::http: connecting to [2404:6800:4002:830::200a]:443
2025-08-20T17:27:42.562604Z DEBUG hyper_util::client::legacy::connect::http: connected to [2404:6800:4002:830::200a]:443
2025-08-20T17:27:42.670457Z TRACE hyper_util::client::legacy::client: http1 handshake complete, spawning background dispatcher task
2025-08-20T17:27:42.670524Z TRACE hyper_util::client::legacy::client: waiting for connection to be ready
2025-08-20T17:27:42.670603Z TRACE hyper_util::client::legacy::client: connection is ready
2025-08-20T17:27:42.670630Z TRACE hyper_util::client::legacy::pool: checkout dropped for ("https", www.googleapis.com)
2025-08-20T17:27:42.884219Z TRACE hyper_util::client::legacy::pool: pool dropped, dropping pooled (("https", www.googleapis.com))
2025-08-20T17:27:42.886835Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=0 rows_returned=0 elapsed=1.963427ms elapsed_secs=0.001963427
2025-08-20T17:27:42.916279Z DEBUG sqlx::query: summary="INSERT INTO users (google_id, …" db.statement="\n\nINSERT INTO users (google_id, email, full_name, picture) VALUES ($1, $2, $3, $4) RETURNING *\n" rows_affected=1 rows_returned=1 elapsed=6.187131ms elapsed_secs=0.006187131
2025-08-20T17:27:42.922334Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=404.334µs elapsed_secs=0.000404334
2025-08-20T17:27:42.922447Z DEBUG backend::api::middleware: Valid token found for user in optional middleware
2025-08-20T17:27:42.927159Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=0 rows_returned=0 elapsed=4.472975ms elapsed_secs=0.004472975
2025-08-20T17:27:51.411998Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=891.347µs elapsed_secs=0.000891347
2025-08-20T17:27:51.412235Z DEBUG backend::api::middleware: Valid token found for user
2025-08-20T17:27:51.412362Z  INFO backend::api::handlers::notes: Upload request received, file size limit: 50 MiB
2025-08-20T17:27:51.416554Z DEBUG sqlx::query: summary="INSERT INTO notes (course_name, …" db.statement="\n\n\n        INSERT INTO notes (course_name, course_code, description, professor_names, tags, has_preview_image, uploader_user_id)\n        VALUES ($1, $2, $3, $4, $5, $6, $7)\n        RETURNING id, course_name, course_code, description, professor_names, tags, is_public, has_preview_image, uploader_user_id, created_at, downloads\n        \n" rows_affected=1 rows_returned=1 elapsed=2.716396ms elapsed_secs=0.002716396
2025-08-20T17:27:51.437911Z DEBUG sqlx::query: summary="UPDATE notes SET has_preview_image …" db.statement="\n\nUPDATE notes SET has_preview_image = $1 WHERE id = $2\n" rows_affected=1 rows_returned=0 elapsed=787.268µs elapsed_secs=0.000787268
2025-08-20T17:27:51.438449Z DEBUG sqlx::query: summary="COMMIT" db.statement="" rows_affected=0 rows_returned=0 elapsed=456.445µs elapsed_secs=0.000456445
2025-08-20T17:27:51.447954Z TRACE axum::serve: connection 127.0.0.1:47556 accepted
2025-08-20T17:27:56.695814Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=470.95µs elapsed_secs=0.00047095
2025-08-20T17:27:56.696228Z DEBUG sqlx::query: summary="SELECT pg_advisory_lock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=336.639µs elapsed_secs=0.000336639
2025-08-20T17:27:56.696471Z  INFO sqlx::postgres::notice: relation "_sqlx_migrations" already exists, skipping
2025-08-20T17:27:56.696510Z DEBUG sqlx::query: summary="CREATE TABLE IF NOT …" db.statement="\n\n\nCREATE TABLE IF NOT EXISTS _sqlx_migrations (\n    version BIGINT PRIMARY KEY,\n    description TEXT NOT NULL,\n    installed_on TIMESTAMPTZ NOT NULL DEFAULT now(),\n    success BOOLEAN NOT NULL,\n    checksum BYTEA NOT NULL,\n    execution_time BIGINT NOT NULL\n);\n                \n" rows_affected=0 rows_returned=0 elapsed=234.01µs elapsed_secs=0.00023401
2025-08-20T17:27:56.697958Z DEBUG sqlx::query: summary="SELECT version FROM _sqlx_migrations …" db.statement="\n\nSELECT version FROM _sqlx_migrations WHERE success = false ORDER BY version LIMIT 1\n" rows_affected=0 rows_returned=0 elapsed=1.400525ms elapsed_secs=0.001400525
2025-08-20T17:27:56.698462Z DEBUG sqlx::query: summary="SELECT version, checksum FROM …" db.statement="\n\nSELECT version, checksum FROM _sqlx_migrations ORDER BY version\n" rows_affected=1 rows_returned=1 elapsed=435.702µs elapsed_secs=0.000435702
2025-08-20T17:27:56.698615Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=86.686µs elapsed_secs=8.6686e-5
2025-08-20T17:27:56.699021Z DEBUG sqlx::query: summary="SELECT pg_advisory_unlock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=359.671µs elapsed_secs=0.000359671
2025-08-20T17:27:56.699094Z  INFO backend: Database connection established.
2025-08-20T17:27:56.699943Z  INFO backend: Server listening on 0.0.0.0:8085
2025-08-20T17:28:30.609975Z TRACE axum::serve: connection 127.0.0.1:59398 accepted
2025-08-20T17:28:30.613949Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=1.635418ms elapsed_secs=0.001635418
2025-08-20T17:28:30.614039Z DEBUG backend::api::middleware: Valid token found for user in optional middleware
2025-08-20T17:28:30.642609Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=1 rows_returned=1 elapsed=3.783691ms elapsed_secs=0.003783691
2025-08-20T17:28:33.185829Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=300.681µs elapsed_secs=0.000300681
2025-08-20T17:28:33.185941Z DEBUG backend::api::middleware: Valid token found for user
2025-08-20T17:28:33.187836Z TRACE axum::serve: connection 127.0.0.1:59400 accepted
2025-08-20T17:28:33.195427Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=327.987µs elapsed_secs=0.000327987
2025-08-20T17:28:33.195538Z DEBUG backend::api::middleware: Valid token found for user
2025-08-20T17:28:33.195996Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=1.423196ms elapsed_secs=0.001423196
2025-08-20T17:28:33.196060Z DEBUG backend::api::middleware: Valid token found for user in optional middleware
2025-08-20T17:28:33.196079Z TRACE axum::serve: connection 127.0.0.1:59404 accepted
2025-08-20T17:28:33.196267Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=193.454µs elapsed_secs=0.000193454
2025-08-20T17:28:33.196319Z DEBUG backend::api::middleware: Valid token found for user in optional middleware
2025-08-20T17:28:33.197468Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=1 rows_returned=1 elapsed=971.513µs elapsed_secs=0.000971513
2025-08-20T17:28:33.221049Z TRACE axum::serve: connection 127.0.0.1:59420 accepted
2025-08-20T17:28:33.226366Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=1 rows_returned=1 elapsed=4.05773ms elapsed_secs=0.00405773
2025-08-20T17:28:36.432245Z DEBUG backend::api::middleware: No Authorization header found in optional middleware
2025-08-20T17:28:36.435527Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=1 rows_returned=1 elapsed=2.902215ms elapsed_secs=0.002902215
2025-08-20T17:28:36.438444Z DEBUG backend::api::middleware: No Authorization header found in optional middleware
2025-08-20T17:28:36.439569Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=1 rows_returned=1 elapsed=778.71µs elapsed_secs=0.00077871
2025-08-20T17:28:41.566567Z TRACE hyper_util::client::legacy::pool: checkout waiting for idle connection: ("https", www.googleapis.com)
2025-08-20T17:28:41.566673Z TRACE hyper_util::client::legacy::connect::http: Http::connect; scheme=Some("https"), host=Some("www.googleapis.com"), port=None
2025-08-20T17:28:41.598434Z DEBUG hyper_util::client::legacy::connect::http: connecting to [2404:6800:4002:80f::200a]:443
2025-08-20T17:28:41.702343Z DEBUG hyper_util::client::legacy::connect::http: connected to [2404:6800:4002:80f::200a]:443
2025-08-20T17:28:41.809210Z TRACE hyper_util::client::legacy::client: http1 handshake complete, spawning background dispatcher task
2025-08-20T17:28:41.809281Z TRACE hyper_util::client::legacy::client: waiting for connection to be ready
2025-08-20T17:28:41.809357Z TRACE hyper_util::client::legacy::client: connection is ready
2025-08-20T17:28:41.809378Z TRACE hyper_util::client::legacy::pool: checkout dropped for ("https", www.googleapis.com)
2025-08-20T17:28:42.022198Z TRACE hyper_util::client::legacy::pool: pool dropped, dropping pooled (("https", www.googleapis.com))
2025-08-20T17:28:42.024269Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=1.317554ms elapsed_secs=0.001317554
2025-08-20T17:28:42.027710Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=287.93µs elapsed_secs=0.00028793
2025-08-20T17:28:42.027776Z DEBUG backend::api::middleware: Valid token found for user in optional middleware
2025-08-20T17:28:42.028961Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=1 rows_returned=1 elapsed=990.552µs elapsed_secs=0.000990552
2025-08-20T17:28:43.799353Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=252.797µs elapsed_secs=0.000252797
2025-08-20T17:28:43.799458Z DEBUG backend::api::middleware: Valid token found for user in optional middleware
2025-08-20T17:28:43.800788Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=1 rows_returned=1 elapsed=1.070446ms elapsed_secs=0.001070446
2025-08-20T17:28:43.804574Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=516.255µs elapsed_secs=0.000516255
2025-08-20T17:28:43.804666Z DEBUG backend::api::middleware: Valid token found for user
2025-08-20T17:28:43.805055Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=186.423µs elapsed_secs=0.000186423
2025-08-20T17:28:43.805120Z DEBUG backend::api::middleware: Valid token found for user in optional middleware
2025-08-20T17:28:43.805810Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=196.189µs elapsed_secs=0.000196189
2025-08-20T17:28:43.805862Z DEBUG backend::api::middleware: Valid token found for user
2025-08-20T17:28:43.806711Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=1 rows_returned=1 elapsed=1.078997ms elapsed_secs=0.001078997
2025-08-20T17:30:28.038011Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=681.756µs elapsed_secs=0.000681756
2025-08-20T17:30:28.038519Z DEBUG sqlx::query: summary="SELECT pg_advisory_lock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=411.323µs elapsed_secs=0.000411323
2025-08-20T17:30:28.038900Z  INFO sqlx::postgres::notice: relation "_sqlx_migrations" already exists, skipping
2025-08-20T17:30:28.038937Z DEBUG sqlx::query: summary="CREATE TABLE IF NOT …" db.statement="\n\n\nCREATE TABLE IF NOT EXISTS _sqlx_migrations (\n    version BIGINT PRIMARY KEY,\n    description TEXT NOT NULL,\n    installed_on TIMESTAMPTZ NOT NULL DEFAULT now(),\n    success BOOLEAN NOT NULL,\n    checksum BYTEA NOT NULL,\n    execution_time BIGINT NOT NULL\n);\n                \n" rows_affected=0 rows_returned=0 elapsed=372.429µs elapsed_secs=0.000372429
2025-08-20T17:30:28.040271Z DEBUG sqlx::query: summary="SELECT version FROM _sqlx_migrations …" db.statement="\n\nSELECT version FROM _sqlx_migrations WHERE success = false ORDER BY version LIMIT 1\n" rows_affected=0 rows_returned=0 elapsed=1.298032ms elapsed_secs=0.001298032
2025-08-20T17:30:28.040704Z DEBUG sqlx::query: summary="SELECT version, checksum FROM …" db.statement="\n\nSELECT version, checksum FROM _sqlx_migrations ORDER BY version\n" rows_affected=1 rows_returned=1 elapsed=386.88µs elapsed_secs=0.00038688
2025-08-20T17:30:28.040868Z DEBUG sqlx::query: summary="SELECT current_database()" db.statement="" rows_affected=1 rows_returned=1 elapsed=79.605µs elapsed_secs=7.9605e-5
2025-08-20T17:30:28.041109Z DEBUG sqlx::query: summary="SELECT pg_advisory_unlock($1)" db.statement="" rows_affected=1 rows_returned=1 elapsed=203.603µs elapsed_secs=0.000203603
2025-08-20T17:30:28.041174Z  INFO backend: Database connection established.
2025-08-20T17:30:28.041965Z  INFO backend: Server listening on 0.0.0.0:8085
2025-08-20T17:30:31.038189Z TRACE axum::serve: connection 127.0.0.1:59618 accepted
2025-08-20T17:30:31.049685Z TRACE axum::serve: connection 127.0.0.1:59626 accepted
2025-08-20T17:30:31.051906Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=2.360545ms elapsed_secs=0.002360545
2025-08-20T17:30:31.052027Z DEBUG backend::api::middleware: Valid token found for user
2025-08-20T17:30:31.078401Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=496.204µs elapsed_secs=0.000496204
2025-08-20T17:30:31.078551Z DEBUG backend::api::middleware: Valid token found for user
2025-08-20T17:30:31.081188Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=2.126529ms elapsed_secs=0.002126529
2025-08-20T17:30:31.081316Z DEBUG backend::api::middleware: Valid token found for user in optional middleware
2025-08-20T17:30:31.084748Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=1 rows_returned=1 elapsed=3.177546ms elapsed_secs=0.003177546
2025-08-20T17:30:31.086504Z DEBUG sqlx::query: summary="SELECT * FROM users …" db.statement="\n\nSELECT * FROM users WHERE google_id = $1\n" rows_affected=1 rows_returned=1 elapsed=226.908µs elapsed_secs=0.000226908
2025-08-20T17:30:31.086581Z DEBUG backend::api::middleware: Valid token found for user in optional middleware
2025-08-20T17:30:31.087735Z DEBUG sqlx::query: summary="SELECT n.id as \"note_id!\", …" db.statement="\n\n\n        SELECT\n            n.id as \"note_id!\",\n            n.course_name as \"note_course_name!\",\n            n.course_code as \"note_course_code!\",\n            n.description as \"note_description\",\n            n.professor_names as \"note_professor_names\",\n            n.tags as \"note_tags!\",\n            n.is_public as \"note_is_public!\",\n            n.has_preview_image as \"note_has_preview_image!\",\n            n.uploader_user_id as \"note_uploader_user_id!\",\n            n.created_at as \"note_created_at!\",\n            n.downloads as \"note_downloads!\",\n            COALESCE(upvote_counts.count, 0) as \"note_upvote_count!\",\n            COALESCE(downvote_counts.count, 0) as \"note_downvote_count!\",\n            user_vote.is_upvote as \"note_user_upvote?\",\n            u.id as \"user_id!\",\n            u.google_id as \"user_google_id!\",\n            u.email as \"user_email!\",\n            u.full_name as \"user_full_name!\",\n            u.reputation as \"user_reputation!\",\n            u.created_at as \"user_created_at!\"\n        FROM\n            notes n\n        JOIN\n            users u ON n.uploader_user_id = u.id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = true\n             GROUP BY note_id) upvote_counts ON n.id = upvote_counts.note_id\n        LEFT JOIN\n            (SELECT note_id, COUNT(*) as count\n             FROM votes\n             WHERE is_upvote = false\n             GROUP BY note_id) downvote_counts ON n.id = downvote_counts.note_id\n        LEFT JOIN\n            votes user_vote ON n.id = user_vote.note_id AND user_vote.user_id = $2\n        ORDER BY\n            n.created_at DESC\n        LIMIT $1\n        \n" rows_affected=1 rows_returned=1 elapsed=919.754µs elapsed_secs=0.000919754
2025-08-20T17:30:31.090150Z TRACE axum::serve: connection 127.0.0.1:59632 accepted
2025-08-20T17:30:32.407968Z DEBUG sqlx::query: summary="UPDATE notes SET downloads …" db.statement="\n\nUPDATE notes SET downloads = downloads + 1 WHERE id = $1\n" rows_affected=1 rows_returned=0 elapsed=1.5985ms elapsed_secs=0.0015985
2025-08-20T17:30:32.521729Z TRACE axum::serve: connection 127.0.0.1:59634 accepted
